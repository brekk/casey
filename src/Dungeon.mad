import type { Random } from "Random"

import type { Vector } from "Invective"

import type { Area } from "@/Area"
import type { TileMap } from "@/Tile"

import Compare from "Compare"
import Ctrl from "Control"
import Float from "Float"
import Fn from "Function"
import IO from "IO"
import Integer from "Integer"
import Int from "Integer"
import List from "List"
import Math from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import {} from "Number"
import R from "Random"

import { Vector, add } from "Invective"

import { Area, anyContainsPoint, anyIntersects, anyIntersectsWithPadding } from "@/Area"
import { makeOdd } from "@/Math"
import {
  Tile,
  TileFloor,
  TileWall,
  atIndex,
  getPossibleCardinalPaths,
  makeTileMap,
  walkTileMap,
} from "@/Tile"



export alias DungeonConfig = {
  edgeDistance :: Integer,
  pad :: Integer,
  rectangularity :: Random -> Integer -> Integer,
  rooms :: Random -> Integer,
  size :: Random -> Integer -> Integer,
  stageLimit :: Integer,
}

// Dungeon(seed, width, height, tiles, areas, config)
export type Dungeon = Dungeon(Random, Integer, Integer, TileMap, List Area, DungeonConfig)

NORTH :: Vector Integer
export NORTH = Vector(0, 1)

SOUTH :: Vector Integer
export SOUTH = Vector(0, -1)

EAST :: Vector Integer
export EAST = Vector(1, 0)

WEST :: Vector Integer
export WEST = Vector(-1, 0)

boundByStageWithDefault :: Integer -> Integer -> Integer -> Integer
export boundByStageWithDefault = (edge, minima, dimension) => Math.min(minima, dimension - edge)

boundByStage :: Integer -> Integer -> Integer
export boundByStage = boundByStageWithDefault(4)

randomPoint :: Integer -> Integer -> Random -> Integer
export randomPoint = (max, size, seed) => pipe(
  Math.floor,
  Float.toInteger,
  R.integer(0, $, seed),
  (r) => r * 2 + 1,
  Fn.when((v) => v + size > max, () => Math.max(1, max - size - 1)),
)((max - size) / 2)

calcRoomSize :: Integer -> Integer -> Integer -> Integer -> Random -> Integer
export calcRoomSize = (size, rectangularity, maximum, edgeDistance, seed) => Float.toInteger(
  Math.round(R.float(seed) * Int.toFloat(Math.min(maximum - edgeDistance, size + rectangularity)))
    + 1,
)

makeRandomRoom :: DungeonConfig -> Integer -> Integer -> Integer -> Random -> Area
export makeRandomRoom = (config, stageWidth, stageHeight, pad, seed) => {
  size = config.size(seed, pad)
  rect = config.rectangularity(seed, size)
  isHotdog = R.boolean(seed)
  calc = calcRoomSize(size, $, $, config.edgeDistance, seed)
  width = calc(isHotdog ? 0 : rect, stageWidth)
  height = calc(!isHotdog ? 0 : rect, stageHeight)
  x = randomPoint(stageWidth, width, seed)
  y = randomPoint(stageHeight, height, seed)
  area = Area(x, y, width, height)
  return area
}

makeRooms :: DungeonConfig -> Integer -> Integer -> Integer -> Integer -> Random -> List Area
export makeRooms = (config, total, stageWidth, stageHeight, pad, seed) => pipe(
  List.repeatWith(() => makeRandomRoom(config, stageWidth, stageHeight, pad, seed)),
  List.reduce((agg, x) => !anyIntersectsWithPadding(1, agg, x) ? [...agg, x] : agg, []),
)(total)

stageDimension :: DungeonConfig -> Integer -> Integer
export stageDimension = (conf, x) => pipe(
  Math.max($, conf.stageLimit),
  makeOdd,
)(x)

threeSteps :: Vector Integer -> Vector Integer -> Vector Integer
export threeSteps = (dir, vec) => pipe(
  add(dir),
  add(dir),
  add(dir),
)(vec)

canCarveFromTilesInDirection :: TileMap -> Vector Integer -> Vector Integer -> Boolean
export canCarveFromTilesInDirection = (tilemap, dir, vec) => pipe(
  threeSteps(dir),
  where {
    Vector(x, y) =>
      pipe(
        atIndex(tilemap, x),
        where {
          Just(Tile(tk, tx, ty)) =>
            tk != TileWall

          Nothing =>
            false
        },
      )(y)
  },
)(vec)

export alias CardinalMovements = List #[Vector Integer, Boolean]

canCarveCardinally :: TileMap -> Vector Integer -> CardinalMovements
export canCarveCardinally = (tilemap, vec) => {
  canCarve = canCarveFromTilesInDirection(tilemap, $, vec)
  return [
    #[NORTH, canCarve(NORTH)],
    #[EAST, canCarve(EAST)],
    #[SOUTH, canCarve(SOUTH)],
    #[WEST, canCarve(WEST)],
  ]
}

cardinalPossibilities :: TileMap -> Vector Integer -> List (Vector Integer)
export cardinalPossibilities = (tilemap, vec) => pipe(
  canCarveCardinally(tilemap),
  List.filter(where { #[dir, can] => can }),
  map(where { #[dir, can] => dir }),
  IO.trace("pasta billy tees"),
)(vec)

growMazeAtPoint = (roomCheck, tilemap, x, y) => {
  isFloor = roomCheck(x, y)
  prevVector = Vector(x, y)
  cells = [prevVector]

  iterations = List.reduce(
    (state, step) => {
      cards = pipe(
        canCarveCardinally(tilemap),
      )(state.prevVector)

      toRemove = []

      return { count: state.count + 1, prevVector, toRemove, cells }
    },
    { count: 0, prevVector, toRemove: [], cells },
  )
  // init, pred, transformer -- ends when false
  if (isFloor) {
    tilemap
  } else {
    tilemap
  }
}

mapSize :: TileMap -> Integer
export mapSize = (tilemap) => pipe(
  List.length,
  (x) => pipe(
    List.nth(0),
    map(List.length),
    fromMaybe(0),
    (y) => x * y,
  )(tilemap),
)(tilemap)


createDungeonWithConfig :: DungeonConfig -> Random -> Integer -> Integer -> Dungeon
export createDungeonWithConfig = (config, seed, _width, _height) => {
  width = stageDimension(config, _width)
  height = stageDimension(config, _height)
  _areas = makeRooms(config, config.rooms(seed), width, height, config.pad, seed)
  IO.trace("ROOMS", _areas)
  _tiles = makeTileMap(TileWall, width, height)
  // getTile = atIndex(_tiles)
  inRoom = anyContainsPoint(_areas)
  tiles = walkTileMap(
    where {
      Tile(_, tx, ty) =>
        Tile(inRoom(tx, ty) ? TileFloor : TileWall, tx, ty)
    },
    _tiles,
  )
  return Dungeon(seed, width, height, tiles, _areas, config)
}


defaultSize :: Random -> Integer -> Integer
defaultSize = (seed, pad) => R.integer(1, 3 + pad, seed) * 2 + 1

defaultRectangularity :: Random -> Integer -> Integer
defaultRectangularity = (seed, size) => R.integer(
    0,
    1 + Float.toInteger(Math.floor(size / 2) + 1),
    seed,
  )
    * 2

DEFAULT_CONFIG :: DungeonConfig
export DEFAULT_CONFIG = {
  pad: 4,
  edgeDistance: 4,
  stageLimit: 5,
  rectangularity: defaultRectangularity,
  size: defaultSize,
  rooms: R.integer(100, 5000),
}

export createDungeon = createDungeonWithConfig(DEFAULT_CONFIG)
