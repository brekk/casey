import type { Vector } from "Invective"

import { EQ, GT, LT } from "Compare"
import Date from "Date"
import Float from "Float"
import IO from "IO"
import List from "List"
import Math from "Math"
import { Just, Nothing } from "Maybe"
import { fromMaybe } from "Maybe"
import { generate, integer, pick } from "Random"
import Set from "Set"
import String from "String"

import { Vector } from "Invective"
import Inv from "Invective"

import Dungeon from "@/Dungeon"
import { log } from "@/Log"
import Maze from "@/Maze"
import { render, renderRoomsWithColor } from "@/Render"
import Tile from "@/Tile"



nowSeed = () => pipe(
  Date.getTimestamp,
  generate,
)(Date.now())

generateDungeon = () => {
  pipe(
    Date.getTimestamp,
    generate,
    Dungeon.createDungeon($, 30, 60),
    render,
    IO.put,
  )(Date.now())
}

pluck = (setX, u) => pipe(
  Set.toList,
  pick($, u),
)(setX)

cardinalCarve = (s, tries) => {
  prev = s.vec
  step = Inv.add(s.vec, Inv.Vector(integer(-5, 5, s.seed), integer(-5, 5, s.seed)))
  inBounds = Inv.concrete((x, y) => x < s.boundaries.x && x >= 0 && y < s.boundaries.y && y >= 0)
  checkBounds = inBounds(step)
  inSet = Set.includes(step, s.paths)
  return if (tries - 1 >= 0 && (!checkBounds || inSet)) do {
    if (inSet) do {
      s.vec := pipe(
        pluck(s.paths),
        fromMaybe(prev),
      )(s.seed)
    }
    return cardinalCarve(s, tries - 1)
  } else if (!inSet && checkBounds) {
    step
  } else {
    prev
  }
}

main = () => {
  pipe(
    log.base("making map..."),
    Tile.makeTileMap($, 30, 30),
    (tileMap) => (
      {
        boundaries: { x: 30, y: 30 },
        tileMap,
        vec: Vector(15, 15),
        seed: nowSeed(),
        paths: Set.fromList([]),
      }
    ),
    List.reduce(
      (state, _) => where(state.vec) {
        Vector(x2, y2) =>
          do {
            state.vec := cardinalCarve(state, 0)
            state.paths := Set.insert(state.vec, state.paths)
            return state
          }
      },
      $,
      List.range(0, 60),
    ),
    (state) => {
      interpolatedPaths = pipe(
        Set.toList,
        List.reduce(
          (agg, curr) => where(agg.prev) {
            Nothing =>
              ({ prev: Just(curr), stack: [] })

            Just(prev) =>
              ({ stack: List.concat(agg.stack, Inv.path(true, prev, curr)), prev: Just(curr) })
          },
          { prev: Nothing, stack: [] },
        ),
        log.walk("PATHS!"),
        .stack,
      )(state.paths)
      return Tile.walkTileMap(
        (x) => List.includes(Tile.toVector(x), interpolatedPaths)
          ? Tile.ofType(x, Tile.TileFloor)
          : x,
        state.tileMap,
      )
    },
    renderRoomsWithColor(true, 30, 30),
    log.base("outcome!"),
  )(Tile.TileVoid)
}
