import type { Random } from "Random"

// import type { Set } from "Set"

import Fn from "Function"
import List from "List"
import { Just } from "Maybe"
import Random from "Random"
import String from "String"



// Stuff(id, name, assets, ownerId)
export type Stuff
  = Mutable(String, String, List String, String)
  | Immutable(String, String, List String, String)
derive Comparable Stuff



////// ACCESSORS

id :: Stuff -> String
export id = where {
  Mutable(x, _, _, _) =>
    x

  Immutable(x, _, _, _) =>
    x
}

name :: Stuff -> String
export name = where {
  Mutable(_, x, _, _) =>
    x

  Immutable(_, x, _, _) =>
    x
}

assets :: Stuff -> List String
export assets = where {
  Mutable(_, _, x, _) =>
    x

  Immutable(_, _, x, _) =>
    x
}

owner :: Stuff -> String
export owner = where {
  Mutable(_, _, _, x) =>
    x

  Immutable(_, _, _, x) =>
    x
}

///////// CONSTRUCTORS

create :: String -> String -> String -> Stuff
export create = Mutable($, $, [], $)

createImmutable :: String -> String -> String -> Stuff
export createImmutable = Immutable($, $, [], $)

//////// TRANSFORMERS

// copy stuff with a new id
clone :: String -> Stuff -> Stuff
export clone = (i, s) => where(s) {
  Mutable(_, n, a, o) =>
    Mutable(i, n, a, o)

  Immutable(_, n, a, o) =>
    Immutable(i, n, a, o)
}

// copy stuff with a new name
rename :: String -> Stuff -> Stuff
export rename = (x, s) => where(s) {
  Mutable(i, _, a, o) =>
    Mutable(i, x, a, o)

  Immutable(i, _, a, o) =>
    Immutable(i, x, a, o)
}

hasName :: String -> Stuff -> Boolean
export hasName = (n, s) => pipe(
  name,
  Fn.equals(n),
)(s)

cast :: Stuff -> Stuff
export cast = (x) => where(x) {
  Mutable(i, n, a, o) =>
    Immutable(i, n, a, o)

  _ =>
    x
}

permute :: Stuff -> Stuff
export permute = (x) => where(x) {
  Immutable(i, n, a, o) =>
    Mutable(i, n, a, o)

  _ =>
    x
}

ALPHANUMERIC = String.split("", "abcdefghjiklmnopqrtuvwxyz0123456789")

uuid :: Random -> String
uuid = (r) => pipe(
  List.repeatWith(() => Random.pick(ALPHANUMERIC, r)),
  List.reduce(
    (agg, x) => where(x) {
      Just(y) =>
        List.append(y, agg)

      _ =>
        agg
    },
    [],
  ),
  (x) => {
    cut = List.slice($, $, x)
    return [cut(0, 3), cut(4, 15), cut(16, 19)]
  },
  map(String.join("")),
  String.join("-"),
)(20)

alias Creator = { copy :: Stuff -> Stuff, hew :: String -> Stuff, make :: String -> Stuff }

makeWithSeed :: String -> Creator
export makeWithSeed = (seed) => {
  r = Random.generateFromString(seed)
  // TODO
  GOD = "GOD"
  return {
    make: (n) => pipe(
      uuid,
      create($, n, GOD),
    )(r),
    hew: (n) => pipe(
      uuid,
      createImmutable($, n, GOD),
    )(r),
    copy: (input) => pipe(
      uuid,
      clone($, input),
    )(r),
  }
}
