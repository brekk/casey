import type { Comparison } from "Compare"
import type { Maybe } from "Maybe"

import { EQ, GT, LT } from "Compare"
import List from "List"
import { isJust } from "Maybe"

import { Vector } from "Invective"



export type TileType = TileWall | TileFloor | TileDoor | TileHazard | TileVoid

// type x y
export type Tile = Tile(TileType, Integer, Integer)

instance Comparable Tile {
  compare = compareTiles
}
export alias Tish = Maybe Tile

// Neighbors(_e, _n, _ne, _nw, _s, _se, _sw, _w)
export type Neighbors = Neighbors(Tish, Tish, Tish, Tish, Tish, Tish, Tish, Tish)
// Cardinal(_e, _n, _s, _w)
export type Cardinal = Cardinal(Tish, Tish, Tish, Tish)

export alias TileMap = List (List Tile)


compareTiles :: Tile -> Tile -> Comparison
export compareTiles = (a, b) => where(#[a, b]) {
  #[Tile(_, x, y), Tile(_, x2, y2)] =>
    if (x == x2 && y == y2) {
      EQ
    } else if ((x == x2 && y < y2) || (x < x2 && y == y2)) {
      LT
    } else {
      GT
    }
}

export fromVector = (tileType) => where {
  Vector(x, y) =>
    Tile(tileType, x, y)
}

export toVector = where {
  Tile(_, x, y) =>
    Vector(x, y)
}

export samePosition = (a, b) => where(#[a, b]) {
  #[Tile(_, x, y), Tile(_, x2, y2)] =>
    x == x2 && y == y2
}

ofType :: Tile -> TileType -> Tile
export ofType = (origin, tileType) => where(origin) {
  Tile(_, x, y) =>
    Tile(tileType, x, y)
}

walkTileMap :: (Tile -> a) -> TileMap -> List (List a)
export walkTileMap = (fn, tiles) => List.reduce(
  (agg, rows) => List.append(map(fn, rows), agg),
  [],
  tiles,
)

atIndex :: TileMap -> Integer -> Integer -> Maybe Tile
export atIndex = (tileMap, x, y) => pipe(
  List.nth(x),
  chain(List.nth(y)),
)(tileMap)

makeTileMap :: TileType -> Integer -> Integer -> TileMap
export makeTileMap = (tt, width, height) => pipe(
  List.range(0),
  map(
    (x) => pipe(
      List.range(0),
      map(Tile(tt, x)),
    )(height),
  ),
)(width)


getPossibleCardinalPaths :: TileMap -> Integer -> Integer -> List Tish
export getPossibleCardinalPaths = (tiles, x, y) => pipe(
  getCardinalNeighbors(tiles, x),
  cardinalToList,
  List.filter(isJust),
)(y)

neighborsToCardinal :: Neighbors -> Cardinal
export neighborsToCardinal = where {
  Neighbors(_e, _n, _, _, _s, _, _, _w) =>
    Cardinal(_e, _n, _s, _w)
}

cardinalToList :: Cardinal -> List Tish
cardinalToList = where {
  Cardinal(_e, _n, _s, _w) =>
    [_e, _n, _s, _w]
}

e :: Neighbors -> Tish
export e = where {
  Neighbors(_e, _, _, _, _, _, _, _) =>
    _e
}
n :: Neighbors -> Tish
export n = where {
  Neighbors(_, _n, _, _, _, _, _, _) =>
    _n
}
ne :: Neighbors -> Tish
export ne = where {
  Neighbors(_, _, _ne, _, _, _, _, _) =>
    _ne
}
nw :: Neighbors -> Tish
export nw = where {
  Neighbors(_, _, _, _nw, _, _, _, _) =>
    _nw
}
s :: Neighbors -> Tish
export s = where {
  Neighbors(_, _, _, _, _s, _, _, _) =>
    _s
}
se :: Neighbors -> Tish
export se = where {
  Neighbors(_, _, _, _, _, _se, _, _) =>
    _se
}
sw :: Neighbors -> Tish
export sw = where {
  Neighbors(_, _, _, _, _, _, _sw, _) =>
    _sw
}
w :: Neighbors -> Tish
export w = where {
  Neighbors(_, _, _, _, _, _, _, _w) =>
    _w
}

getNeighbors :: TileMap -> Integer -> Integer -> Neighbors
export getNeighbors = (tiles, x, y) => {
  at = atIndex(tiles)
  return Neighbors(
    at(x + 1, y),
    at(x, y - 1),
    at(x + 1, y - 1),
    at(x - 1, y - 1),
    at(x, y + 1),
    at(x + 1, y + 1),
    at(x - 1, y + 1),
    at(x - 1, y),
  )
}

getCardinalNeighbors :: TileMap -> Integer -> Integer -> Cardinal
export getCardinalNeighbors = (tiles, x, y) => {
  at = atIndex(tiles)
  return Cardinal(at(x + 1, y), at(x, y - 1), at(x, y + 1), at(x - 1, y))
}
