import { any } from "List"



// x y width height
export type Area = Area(Integer, Integer, Integer, Integer)

// top right bottom left
export type BoundingBox = Box(Integer, Integer, Integer, Integer)


getBoundingBox :: Area -> BoundingBox
export getBoundingBox = where {
  Area(x, y, w, h) =>
    Box(y, x + w, y + h, x)
}

padBoundingBox :: Integer -> BoundingBox -> BoundingBox
export padBoundingBox = (i, bb) => where(bb) {
  Box(t, r, b, l) =>
    Box(t - i, r + i, b + i, l - i)
}

containsPoint :: Area -> Integer -> Integer -> Boolean
export containsPoint = (area, x, y) => pipe(
  getBoundingBox,
  where {
    Box(t, r, b, l) =>
      !(x < l || x > r || y < t || y > b)
  },
)(area)

intersectsWithPadding :: Integer -> Area -> Area -> Boolean
export intersectsWithPadding = (i, j, k) => {
  box = pipe(
    getBoundingBox,
    padBoundingBox(i),
  )
  jj = box(j)
  kk = box(k)
  return where(#[jj, kk]) {
    #[Box(t, r, b, l), Box(t2, r2, b2, l2)] =>
      !(l2 > r || r2 < l || t2 > b || b2 < t)
  }
}

export intersects = intersectsWithPadding(0)

anyIntersectsWithPadding :: Integer -> List Area -> Area -> Boolean
export anyIntersectsWithPadding = (i, areas, r) => any(intersectsWithPadding(i, r), areas)
export anyIntersects = anyIntersectsWithPadding(0)

anyContainsPoint :: List Area -> Integer -> Integer -> Boolean
export anyContainsPoint = (areas, x, y) => any(containsPoint($, x, y))(areas)

isEdge :: Integer -> Integer -> Integer -> Boolean
export isEdge = (min, max, z) => z == min || z == max

isBoundary :: BoundingBox -> Integer -> Integer -> Boolean
export isBoundary = (box, x, y) => pipe(
  where {
    Box(t, r, b, l) =>
      isEdge(t, b, y) || isEdge(r, l, x)
  },
)(box)
