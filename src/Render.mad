import type { Area } from "@/Area"
import type { Dungeon } from "@/Dungeon"
import type { Tile, TileMap } from "@/Tile"

import Fn from "Function"
import { identity } from "Function"
import Integer from "Integer"
import List from "List"
import String from "String"
import Terminal from "Terminal"

import { Area, anyContainsPoint, getBoundingBox, isBoundary } from "@/Area"
import { Dungeon } from "@/Dungeon"
import { trailingDigit } from "@/Math"
import { Tile, TileFloor, TileWall, walkTileMap } from "@/Tile"



export alias CharacterMap = {
  BOUNDARY :: String,
  CORNER_BL :: String,
  CORNER_BR :: String,
  CORNER_TL :: String,
  CORNER_TR :: String,
  ROOM :: String,
  SPACE :: String,
  SPACE_GRID :: String,
  TICK_DOWN :: String,
  TICK_LEFT :: String,
  TICK_RIGHT :: String,
  TICK_UP :: String,
}



export alias RenderConfig = {
  boundary :: (String -> String) -> String -> Integer -> String,
  characterMap :: CharacterMap,
  colorize :: Boolean,
  endBoundary :: CharacterMap -> List String -> List String,
  endLineCharacter :: CharacterMap -> (String -> String) -> Integer -> String,
}


isZero = Fn.equals(0)
unwords = String.join("")
unlines = String.join("\n")



export condColor = (yes, fn, x) => yes ? fn(x) : x

renderBoundaryWithConfig :: RenderConfig -> String -> (String -> String) -> Integer -> String
export renderBoundaryWithConfig = (config, tick, fn, i) => {
  fun = condColor(config.colorize, fn)
  return Fn.ifElse(isZero, Fn.always(config.characterMap.CORNER_TL), config.boundary(fun, tick), i)
}


renderTileWithConfig :: RenderConfig -> Integer -> Integer -> Tile -> String
export renderTileWithConfig = (config, stageWidth, stageHeight, tile) => {
  bound = renderBoundaryWithConfig(config)
  return where(tile) {
    Tile(tk, tx, ty) =>
      if (tk == TileFloor) {
        config.characterMap.ROOM
      } else if (
        tk == TileWall && isBoundary(getBoundingBox(Area(0, 0, stageWidth, stageHeight)), tx, ty)
      ) {
        ty == 0
          ? bound(config.characterMap.TICK_RIGHT, Terminal.text.green, tx)
          : bound(config.characterMap.TICK_DOWN, Terminal.text.yellow, ty)
      } else {
        trailingDigit(ty) == 0 || trailingDigit(tx) == 0
          ? config.characterMap.SPACE_GRID
          : config.characterMap.SPACE
      }
  }
}

renderFinalLineWithConfig :: RenderConfig -> Integer -> String -> String
renderFinalLineWithConfig = (config, h, r) => {
  enred = condColor(config.colorize, Terminal.text.red)

  return r
    ++ "\n"
    ++ pipe(
      List.range(0),
      map(config.endLineCharacter(config.characterMap, enred)),
      unwords,
    )(h)
    ++ config.characterMap.CORNER_BR
}

renderRoomsWithConfig :: RenderConfig -> Integer -> Integer -> TileMap -> List String
export renderRoomsWithConfig = (config, w, h, tiles) => pipe(
  walkTileMap(renderTileWithConfig(config, w, h)),
  map(config.endBoundary(config.characterMap)),
  map(String.join("")),
)(tiles)

renderWithConfig :: RenderConfig -> Dungeon -> String
export renderWithConfig = (config, raw) => where(raw) {
  Dungeon(_, w, h, tiles, areas, _) =>
    do {
      return pipe(
        renderRoomsWithConfig(config, w, h),
        unlines,
        renderFinalLineWithConfig(config, h),
      )(tiles)
    }
}
