import type { Area } from "@/Area"
import type { Dungeon } from "@/Dungeon"
import type { Tile, TileMap } from "@/Tile"

import Fn from "Function"
import { identity } from "Function"
import Integer from "Integer"
import List from "List"
import String from "String"
import Terminal from "Terminal"

import { Area, anyContainsPoint, getBoundingBox, isBoundary } from "@/Area"
import { Dungeon } from "@/Dungeon"
import { trailingDigit } from "@/Math"
import { stripColor } from "@/String"
import { Tile, TileFloor, TileWall, walkTileMap } from "@/Tile"
import {
  ENTITY_BOUNDARY,
  ENTITY_CORNER,
  ENTITY_ROOM,
  ENTITY_SPACE,
  ENTITY_TICK_DOWN,
  ENTITY_TICK_LEFT,
  ENTITY_TICK_RIGHT,
  ENTITY_TICK_UP,
} from "@/constants"



isZero = Fn.equals(0)
unwords = String.join("")
unlines = String.join("\n")
endBoundarySwap = (c) => (stripColor(c) == ENTITY_TICK_RIGHT ? ENTITY_TICK_LEFT : c)

addEndBoundaries = where {
  [] =>
    []

  [x] =>
    [x]

  [x, ...y] =>
    pipe(
      List.concat([x]),
      List.append(endBoundarySwap(x)),
    )(y)
}

export condColor = (yes, fn, x) => yes ? fn(x) : x

renderBoundaryWithColor :: Boolean -> String -> (String -> String) -> Integer -> String
export renderBoundaryWithColor = (colorize, tick, fn, i) => {
  fun = condColor(colorize, fn)
  return Fn.ifElse(
    isZero,
    Fn.always(ENTITY_CORNER),
    pipe(
      trailingDigit,
      Fn.ifElse(
        isZero,
        Fn.always(tick),
        pipe(
          show,
          fun,
        ),
      ),
    ),
    i,
  )
}


renderTileWithColor :: Boolean -> Integer -> Integer -> Tile -> String
export renderTileWithColor = (colorize, stageWidth, stageHeight, tile) => {
  bound = renderBoundaryWithColor(colorize)
  return where(tile) {
    Tile(tk, tx, ty) =>
      if (tk == TileFloor) {
        ENTITY_ROOM
      } else if (
        tk == TileWall && isBoundary(getBoundingBox(Area(0, 0, stageWidth, stageHeight)), tx, ty)
      ) {
        ty == 0
          ? bound(ENTITY_TICK_RIGHT, Terminal.text.green, tx)
          : bound(ENTITY_TICK_DOWN, Terminal.text.yellow, ty)
      } else {
        ENTITY_SPACE
      }
  }
}

renderFinalLineWithColor :: Boolean -> Integer -> String -> String
renderFinalLineWithColor = (colorize, h, r) => {
  enred = condColor(colorize, Terminal.text.red)
  nonZero = pipe(
    trailingDigit,
    Fn.ifElse(
      isZero,
      Fn.always(ENTITY_TICK_UP),
      pipe(
        show,
        enred,
      ),
    ),
  )
  return r
    ++ "\n"
    ++ pipe(
      List.range(0),
      map(Fn.ifElse(isZero, Fn.always(ENTITY_CORNER), nonZero)),
      unwords,
    )(h)
    ++ ENTITY_CORNER
}

renderRoomsWithColor :: Boolean -> Integer -> Integer -> TileMap -> List String
export renderRoomsWithColor = (colorize, w, h, tiles) => pipe(
  walkTileMap(renderTileWithColor(colorize, w, h)),
  map(addEndBoundaries),
  map(String.join("")),
)(tiles)

renderWithColor :: Boolean -> Dungeon -> String
export renderWithColor = (colorize, raw) => where(raw) {
  Dungeon(_, w, h, tiles, areas) =>
    pipe(
      renderRoomsWithColor(colorize, w, h),
      unlines,
      renderFinalLineWithColor(colorize, h),
    )(tiles)
}

// testing without colors is easy
export renderBoundary = renderBoundaryWithColor(false)
export renderFinalLine = renderFinalLineWithColor(false)
export renderRooms = renderRoomsWithColor(false)
export render = renderWithColor(false)
